<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>input&#x2F;charts&#x2F;PieSeries.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Anim.html">Anim</a></li>
            
                <li><a href="..&#x2F;classes/AreaSeries.html">AreaSeries</a></li>
            
                <li><a href="..&#x2F;classes/AreaSplineSeries.html">AreaSplineSeries</a></li>
            
                <li><a href="..&#x2F;classes/Axis.html">Axis</a></li>
            
                <li><a href="..&#x2F;classes/AxisType.html">AxisType</a></li>
            
                <li><a href="..&#x2F;classes/BarSeries.html">BarSeries</a></li>
            
                <li><a href="..&#x2F;classes/BottomAxisLayout.html">BottomAxisLayout</a></li>
            
                <li><a href="..&#x2F;classes/CartesianChart.html">CartesianChart</a></li>
            
                <li><a href="..&#x2F;classes/CartesianSeries.html">CartesianSeries</a></li>
            
                <li><a href="..&#x2F;classes/CategoryAxis.html">CategoryAxis</a></li>
            
                <li><a href="..&#x2F;classes/Chart.html">Chart</a></li>
            
                <li><a href="..&#x2F;classes/ChartBase.html">ChartBase</a></li>
            
                <li><a href="..&#x2F;classes/ChartLegend.html">ChartLegend</a></li>
            
                <li><a href="..&#x2F;classes/ColumnSeries.html">ColumnSeries</a></li>
            
                <li><a href="..&#x2F;classes/ComboSeries.html">ComboSeries</a></li>
            
                <li><a href="..&#x2F;classes/ComboSplineSeries.html">ComboSplineSeries</a></li>
            
                <li><a href="..&#x2F;classes/CurveUtil.html">CurveUtil</a></li>
            
                <li><a href="..&#x2F;classes/Easing.html">Easing</a></li>
            
                <li><a href="..&#x2F;classes/EasingFoo.html">EasingFoo</a></li>
            
                <li><a href="..&#x2F;classes/EllipseGroup.html">EllipseGroup</a></li>
            
                <li><a href="..&#x2F;classes/Fills.html">Fills</a></li>
            
                <li><a href="..&#x2F;classes/Foo.Bar.html">Foo.Bar</a></li>
            
                <li><a href="..&#x2F;classes/Graph.html">Graph</a></li>
            
                <li><a href="..&#x2F;classes/Gridlines.html">Gridlines</a></li>
            
                <li><a href="..&#x2F;classes/GroupCircle.html">GroupCircle</a></li>
            
                <li><a href="..&#x2F;classes/GroupDiamond.html">GroupDiamond</a></li>
            
                <li><a href="..&#x2F;classes/GroupRect.html">GroupRect</a></li>
            
                <li><a href="..&#x2F;classes/Histogram.html">Histogram</a></li>
            
                <li><a href="..&#x2F;classes/HorizontalLegendLayout.html">HorizontalLegendLayout</a></li>
            
                <li><a href="..&#x2F;classes/JSON.html">JSON</a></li>
            
                <li><a href="..&#x2F;classes/LeftAxisLayout.html">LeftAxisLayout</a></li>
            
                <li><a href="..&#x2F;classes/Lines.html">Lines</a></li>
            
                <li><a href="..&#x2F;classes/LineSeries.html">LineSeries</a></li>
            
                <li><a href="..&#x2F;classes/Main.html">Main</a></li>
            
                <li><a href="..&#x2F;classes/MarkerSeries.html">MarkerSeries</a></li>
            
                <li><a href="..&#x2F;classes/myclass.html">myclass</a></li>
            
                <li><a href="..&#x2F;classes/mywidget.SubWidget.html">mywidget.SubWidget</a></li>
            
                <li><a href="..&#x2F;classes/mywidget.SubWidget2.html">mywidget.SubWidget2</a></li>
            
                <li><a href="..&#x2F;classes/mywidget.SuperWidget.html">mywidget.SuperWidget</a></li>
            
                <li><a href="..&#x2F;classes/NumericAxis.html">NumericAxis</a></li>
            
                <li><a href="..&#x2F;classes/OtherClass.html">OtherClass</a></li>
            
                <li><a href="..&#x2F;classes/OtherClass2.html">OtherClass2</a></li>
            
                <li><a href="..&#x2F;classes/P.storage.html">P.storage</a></li>
            
                <li><a href="..&#x2F;classes/P.storage.LocalStore.html">P.storage.LocalStore</a></li>
            
                <li><a href="..&#x2F;classes/P.storage.Store.html">P.storage.Store</a></li>
            
                <li><a href="..&#x2F;classes/PieChart.html">PieChart</a></li>
            
                <li><a href="..&#x2F;classes/PieSeries.html">PieSeries</a></li>
            
                <li><a href="..&#x2F;classes/Plots.html">Plots</a></li>
            
                <li><a href="..&#x2F;classes/Renderer.html">Renderer</a></li>
            
                <li><a href="..&#x2F;classes/RightAxisLayout.html">RightAxisLayout</a></li>
            
                <li><a href="..&#x2F;classes/ShapeGroup.html">ShapeGroup</a></li>
            
                <li><a href="..&#x2F;classes/SplineSeries.html">SplineSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedAreaSeries.html">StackedAreaSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedAreaSplineSeries.html">StackedAreaSplineSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedAxis.html">StackedAxis</a></li>
            
                <li><a href="..&#x2F;classes/StackedBarSeries.html">StackedBarSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedColumnSeries.html">StackedColumnSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedComboSeries.html">StackedComboSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedComboSplineSeries.html">StackedComboSplineSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedLineSeries.html">StackedLineSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedMarkerSeries.html">StackedMarkerSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackedSplineSeries.html">StackedSplineSeries</a></li>
            
                <li><a href="..&#x2F;classes/StackingUtil.html">StackingUtil</a></li>
            
                <li><a href="..&#x2F;classes/TimeAxis.html">TimeAxis</a></li>
            
                <li><a href="..&#x2F;classes/TopAxisLayout.html">TopAxisLayout</a></li>
            
                <li><a href="..&#x2F;classes/VerticalLegendLayout.html">VerticalLegendLayout</a></li>
            
                <li><a href="..&#x2F;classes/YUI~dump.html">YUI~dump</a></li>
            
                <li><a href="..&#x2F;classes/YUI~oop.html">YUI~oop</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/anim.html">anim</a></li>
            
                <li><a href="..&#x2F;modules/anim-easing.html">anim-easing</a></li>
            
                <li><a href="..&#x2F;modules/anim-easing-foo.html">anim-easing-foo</a></li>
            
                <li><a href="..&#x2F;modules/charts.html">charts</a></li>
            
                <li><a href="..&#x2F;modules/charts-legend.html">charts-legend</a></li>
            
                <li><a href="..&#x2F;modules/dump.html">dump</a></li>
            
                <li><a href="..&#x2F;modules/ExampleModule.html">ExampleModule</a></li>
            
                <li><a href="..&#x2F;modules/foobar.html">foobar</a></li>
            
                <li><a href="..&#x2F;modules/graphics.html">graphics</a></li>
            
                <li><a href="..&#x2F;modules/json.html">json</a></li>
            
                <li><a href="..&#x2F;modules/json-parse.html">json-parse</a></li>
            
                <li><a href="..&#x2F;modules/json-stringify.html">json-stringify</a></li>
            
                <li><a href="..&#x2F;modules/myapp_views_index.html">myapp&#x2F;views&#x2F;index</a></li>
            
                <li><a href="..&#x2F;modules/mymodule.html">mymodule</a></li>
            
                <li><a href="..&#x2F;modules/mysubmodule.html">mysubmodule</a></li>
            
                <li><a href="..&#x2F;modules/oop.html">oop</a></li>
            
                <li><a href="..&#x2F;modules/P.storage.html">P.storage</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: input&#x2F;charts&#x2F;PieSeries.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * PieSeries visualizes data as a circular chart divided into wedges which represent data as a 
 * percentage of a whole.
 *
 * @module charts
 * @class PieSeries
 * @constructor
 * @extends MarkerSeries
 *&#x2F;
Y.PieSeries = Y.Base.create(&quot;pieSeries&quot;, Y.MarkerSeries, [], { 
    &#x2F;**
     * Image map used for interactivity when rendered with canvas.
     *
     * @property _map
     * @type HTMLElement
     * @private
     *&#x2F;
    _map: null,

    &#x2F;**
     * Image used for image map when rendered with canvas.
     *
     * @property _image
     * @type HTMLElement
     * @private
     *&#x2F;
    _image: null,

    &#x2F;**
     * Creates or updates the image map when rendered with canvas.
     *
     * @method _setMap
     * @private
     *&#x2F;
    _setMap: function()
    {
        var id = &quot;pieHotSpotMapi_&quot; + Math.round(100000 * Math.random()),
            cb = this.get(&quot;graph&quot;).get(&quot;contentBox&quot;),
            areaNode;
        if(this._image)
        {
            cb.removeChild(this._image);
            while(this._areaNodes &amp;&amp; this._areaNodes.length &gt; 0)
            {
                areaNode = this._areaNodes.shift();
                this._map.removeChild(areaNode);
            }
            cb.removeChild(this._map);
        }
        this._image = DOCUMENT.createElement(&quot;img&quot;); 
        this._image.src = &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAABCAYAAAD9yd&#x2F;wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJJREFUeNpiZGBgSGPAAgACDAAIkABoFyloZQAAAABJRU5ErkJggg==&quot;;
        cb.appendChild(this._image);
        this._image.setAttribute(&quot;usemap&quot;, &quot;#&quot; + id);
        this._image.style.zIndex = 3;
        this._image.style.opacity = 0;
        this._image.setAttribute(&quot;alt&quot;, &quot;imagemap&quot;);
        this._map = DOCUMENT.createElement(&quot;map&quot;);
        this._map.style.zIndex = 5;
        cb.appendChild(this._map);
        this._map.setAttribute(&quot;name&quot;, id);
        this._map.setAttribute(&quot;id&quot;, id);
        this._areaNodes = [];
    },

    &#x2F;**
     * Storage for &#x60;categoryDisplayName&#x60; attribute.
     *
     * @property _categoryDisplayName
     * @private
     *&#x2F;
    _categoryDisplayName: null,
    
    &#x2F;**
     * Storage for &#x60;valueDisplayName&#x60; attribute.
     *
     * @property _valueDisplayName
     * @private
     *&#x2F;
    _valueDisplayName: null,

    &#x2F;**
     * Adds event listeners.
     *
     * @method addListeners
     * @private
     *&#x2F;
    addListeners: function()
    {
        var categoryAxis = this.get(&quot;categoryAxis&quot;),
            valueAxis = this.get(&quot;valueAxis&quot;);
        if(categoryAxis)
        {
            categoryAxis.after(&quot;dataReady&quot;, Y.bind(this._categoryDataChangeHandler, this));
            categoryAxis.after(&quot;dataUpdate&quot;, Y.bind(this._categoryDataChangeHandler, this));
        }
        if(valueAxis)
        {
            valueAxis.after(&quot;dataReady&quot;, Y.bind(this._valueDataChangeHandler, this));
            valueAxis.after(&quot;dataUpdate&quot;, Y.bind(this._valueDataChangeHandler, this));
        }
        this.after(&quot;categoryAxisChange&quot;, this.categoryAxisChangeHandler);
        this.after(&quot;valueAxisChange&quot;, this.valueAxisChangeHandler);
        this.after(&quot;stylesChange&quot;, this._updateHandler);
    },
    
    &#x2F;**
     * Draws the series.
     *
     * @method validate
     * @private
     *&#x2F;
    validate: function()
    {
        this.draw();
        this._renderered = true;
    },

    &#x2F;**
     * Event handler for the categoryAxisChange event.
     *
     * @method _categoryAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     *&#x2F;
    _categoryAxisChangeHandler: function(e)
    {
        var categoryAxis = this.get(&quot;categoryAxis&quot;);
        categoryAxis.after(&quot;dataReady&quot;, Y.bind(this._categoryDataChangeHandler, this));
        categoryAxis.after(&quot;dataUpdate&quot;, Y.bind(this._categoryDataChangeHandler, this));
    },
    
    &#x2F;**
     * Event handler for the valueAxisChange event.
     *
     * @method _valueAxisChangeHandler
     * @param {Object} e Event object.
     * @private
     *&#x2F;
    _valueAxisChangeHandler: function(e)
    {
        var valueAxis = this.get(&quot;valueAxis&quot;);
        valueAxis.after(&quot;dataReady&quot;, Y.bind(this._valueDataChangeHandler, this));
        valueAxis.after(&quot;dataUpdate&quot;, Y.bind(this._valueDataChangeHandler, this));
    },
	
    &#x2F;**
     * Constant used to generate unique id.
     *
     * @property GUID
     * @type String
     * @private
     *&#x2F;
    GUID: &quot;pieseries&quot;,
	
    &#x2F;**
     * Event handler for categoryDataChange event.
     *
     * @method _categoryDataChangeHandler
     * @param {Object} event Event object.
     * @private 
     *&#x2F;
    _categoryDataChangeHandler: function(event)
    {
       if(this._rendered &amp;&amp; this.get(&quot;categoryKey&quot;) &amp;&amp; this.get(&quot;valueKey&quot;))
        {
            this.draw();
        }
    },

    &#x2F;**
     * Event handler for valueDataChange event.
     *
     * @method _valueDataChangeHandler
     * @param {Object} event Event object.
     * @private 
     *&#x2F;
    _valueDataChangeHandler: function(event)
    {
        if(this._rendered &amp;&amp; this.get(&quot;categoryKey&quot;) &amp;&amp; this.get(&quot;valueKey&quot;))
        {
            this.draw();
        }
    },
   
    &#x2F;**
     * Draws the series. Overrides the base implementation.
     *
     * @method draw
     * @protected
     *&#x2F;
    draw: function()
    {
        var graph = this.get(&quot;graph&quot;),
            w = graph.get(&quot;width&quot;),
            h = graph.get(&quot;height&quot;);
        if(isFinite(w) &amp;&amp; isFinite(h) &amp;&amp; w &gt; 0 &amp;&amp; h &gt; 0)
        {   
            this._rendered = true;
            if(this._drawing)
            {
                this._callLater = true;
                return;
            }
            this._drawing = true;
            this._callLater = false;
            this.drawSeries();
            this._drawing = false;
            if(this._callLater)
            {
                this.draw();
            }
            else
            {
                this.fire(&quot;drawingComplete&quot;);
            }
        }
    },

    &#x2F;**
     * Draws the markers
     *
     * @method drawPlots
     * @protected
     *&#x2F;
    drawPlots: function()
    {
        var values = this.get(&quot;valueAxis&quot;).getDataByKey(this.get(&quot;valueKey&quot;)).concat(),
            catValues = this.get(&quot;categoryAxis&quot;).getDataByKey(this.get(&quot;categoryKey&quot;)).concat(),
            totalValue = 0,
            itemCount = values.length,
            styles = this.get(&quot;styles&quot;).marker,
            fillColors = styles.fill.colors,
            fillAlphas = styles.fill.alphas || [&quot;1&quot;],
            borderColors = styles.border.colors,
            borderWeights = [styles.border.weight],
            borderAlphas = [styles.border.alpha],
            tbw = borderWeights.concat(),
            tbc = borderColors.concat(),
            tba = borderAlphas.concat(),
            tfc,
            tfa,
            padding = styles.padding,
            graph = this.get(&quot;graph&quot;),
            minDimension = Math.min(graph.get(&quot;width&quot;), graph.get(&quot;height&quot;)),
            w = minDimension - (padding.left + padding.right),
            h = minDimension - (padding.top + padding.bottom),
            startAngle = -90,
            halfWidth = w &#x2F; 2,
            halfHeight = h &#x2F; 2,
            radius = Math.min(halfWidth, halfHeight),
            i = 0,
            value,
            angle = 0,
            lc,
            la,
            lw,
            wedgeStyle,
            marker,
            graphOrder = this.get(&quot;graphOrder&quot;),
            isCanvas = Y.Graphic.NAME == &quot;canvasGraphic&quot;;
        for(; i &lt; itemCount; ++i)
        {
            value = parseFloat(values[i]);
            
            values.push(value);
            if(!isNaN(value))
            {
                totalValue += value;
            }
        }
        
        tfc = fillColors ? fillColors.concat() : null;
        tfa = fillAlphas ? fillAlphas.concat() : null;
        this._createMarkerCache();
        if(isCanvas)
        {
            this._setMap();
            this._image.width = w;
            this._image.height = h;
        }
        for(i = 0; i &lt; itemCount; i++)
        {
            value = values[i];
            if(totalValue === 0)
            {
                angle = 360 &#x2F; values.length;
            }
            else
            {
                angle = 360 * (value &#x2F; totalValue);
            }
            angle = Math.round(angle);
            if(tfc &amp;&amp; tfc.length &lt; 1)
            {
                tfc = fillColors.concat();
            }
            if(tfa &amp;&amp; tfa.length &lt; 1)
            {
                tfa = fillAlphas.concat();
            }
            if(tbw &amp;&amp; tbw.length &lt; 1)
            {
                tbw = borderWeights.concat();
            }
            if(tbw &amp;&amp; tbc.length &lt; 1)
            {
                tbc = borderColors.concat();
            }
            if(tba &amp;&amp; tba.length &lt; 1)
            {
                tba = borderAlphas.concat();
            }
            lw = tbw ? tbw.shift() : null;
            lc = tbc ? tbc.shift() : null;
            la = tba ? tba.shift() : null;
            startAngle += angle;
            wedgeStyle = {
                border: {
                    color:lc,
                    weight:lw,
                    alpha:la
                },
                fill: {
                    color:tfc ? tfc.shift() : this._getDefaultColor(i, &quot;slice&quot;),
                    alpha:tfa ? tfa.shift() : null
                },
                type: &quot;pieslice&quot;,
                arc: angle,
                radius: radius,
                startAngle: startAngle,
                cx: halfWidth,
                cy: halfHeight,
                width: w,
                height: h
            };
            marker = this.getMarker(wedgeStyle, graphOrder, i);
            if(isCanvas)
            {
                this._addHotspot(wedgeStyle, graphOrder, i);
            }
        }
        this._clearMarkerCache();
    },

    &#x2F;**
     *  Adds an interactive map when rendering in canvas.
     *
     *  @method _addHotspot
     *  @param {Object} cfg Object containing data used to draw the hotspot
     *  @param {Number} seriesIndex Index of series in the &#x60;seriesCollection&#x60;.
     *  @param {Number} index Index of the marker using the hotspot.
     *  @private
     *&#x2F;
    _addHotspot: function(cfg, seriesIndex, index)
    {
        var areaNode = DOCUMENT.createElement(&quot;area&quot;),
            i = 1,
            x = cfg.cx,
            y = cfg.cy, 
            arc = cfg.arc,
            startAngle = cfg.startAngle - arc, 
            endAngle = cfg.startAngle,
            radius = cfg.radius, 
            ax = x + Math.cos(startAngle &#x2F; 180 * Math.PI) * radius,
            ay = y + Math.sin(startAngle &#x2F; 180 * Math.PI) * radius,
            bx = x + Math.cos(endAngle &#x2F; 180 * Math.PI) * radius,
            by = y + Math.sin(endAngle &#x2F; 180 * Math.PI) * radius,
            numPoints = Math.floor(arc&#x2F;10) - 1,
            divAngle = (arc&#x2F;(Math.floor(arc&#x2F;10)) &#x2F; 180) * Math.PI,
            angleCoord = Math.atan((ay - y)&#x2F;(ax - x)),
            pts = x + &quot;, &quot; + y + &quot;, &quot; + ax + &quot;, &quot; + ay,
            cosAng,
            sinAng,
            multDivAng;
        for(i = 1; i &lt;= numPoints; ++i)
        {
            multDivAng = divAngle * i;
            cosAng = Math.cos(angleCoord + multDivAng);
            sinAng = Math.sin(angleCoord + multDivAng);
            if(startAngle &lt;= 90)
            {
                pts += &quot;, &quot; + (x + (radius * Math.cos(angleCoord + (divAngle * i))));
                pts += &quot;, &quot; + (y + (radius * Math.sin(angleCoord + (divAngle * i))));
            }
            else
            {
                pts += &quot;, &quot; + (x - (radius * Math.cos(angleCoord + (divAngle * i))));
                pts += &quot;, &quot; + (y - (radius * Math.sin(angleCoord + (divAngle * i))));
            }
        }
        pts += &quot;, &quot; + bx + &quot;, &quot; + by;
        pts += &quot;, &quot; + x + &quot;, &quot; + y;
        this._map.appendChild(areaNode);
        areaNode.setAttribute(&quot;class&quot;, SERIES_MARKER);
        areaNode.setAttribute(&quot;id&quot;, &quot;hotSpot_&quot; + seriesIndex + &quot;_&quot; + index);
        areaNode.setAttribute(&quot;shape&quot;, &quot;polygon&quot;);
        areaNode.setAttribute(&quot;coords&quot;, pts);
        this._areaNodes.push(areaNode);

    },

    &#x2F;**
     * Resizes and positions markers based on a mouse interaction.
     *
     * @method updateMarkerState
     * @param {String} type state of the marker
     * @param {Number} i index of the marker
     * @protected
     *&#x2F;
    updateMarkerState: function(type, i)
    {
        if(this._markers[i])
        {
            var state = this._getState(type),
                markerStyles,
                indexStyles,
                marker = this._markers[i],
                styles = this.get(&quot;styles&quot;).marker; 
            markerStyles = state == &quot;off&quot; || !styles[state] ? styles : styles[state]; 
            indexStyles = this._mergeStyles(markerStyles, {});
            indexStyles.fill.color = indexStyles.fill.colors[i % indexStyles.fill.colors.length];
            indexStyles.fill.alpha = indexStyles.fill.alphas[i % indexStyles.fill.alphas.length];
            marker.set(indexStyles);
        }
    },
    
    &#x2F;**
     * Creates a shape to be used as a marker.
     *
     * @method _createMarker
     * @param {Object} styles Hash of style properties.
     * @param {Number} order Order of the series.
     * @param {Number} index Index within the series associated with the marker.
     * @return Shape
     * @private
     *&#x2F;
    _createMarker: function(styles, order, index)
    {
        var graphic = this.get(&quot;graphic&quot;),
            marker,
            cfg = Y.clone(styles);
        graphic.set(&quot;autoDraw&quot;, false);
        marker = graphic.addShape(cfg); 
        marker.addClass(SERIES_MARKER);
        return marker;
    },
    
    &#x2F;**
     * Creates a cache of markers for reuse.
     *
     * @method _createMarkerCache
     * @private
     *&#x2F;
    _clearMarkerCache: function()
    {
        var len = this._markerCache.length,
            i = 0,
            marker;
        for(; i &lt; len; ++i)
        {
            marker = this._markerCache[i];
            if(marker)
            {
                marker.destroy();
            }
        }
        this._markerCache = [];
    },

    &#x2F;**
     * Gets the default style values for the markers.
     *
     * @method _getPlotDefaults
     * @return Object
     * @private
     *&#x2F;
    _getPlotDefaults: function()
    {
         var defs = {
            padding:{
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            },
            fill:{
                alphas:[&quot;1&quot;]
            },
            border: {
                weight: 0,
                alpha: 1
            }
        };
        defs.fill.colors = this._defaultSliceColors;
        defs.border.colors = this._defaultBorderColors;
        return defs;
    },

    &#x2F;**
     * Collection of default colors used for lines in a series when not specified by user.
     *
     * @property _defaultLineColors
     * @type Array
     * @protected
     *&#x2F;
    _defaultLineColors:[&quot;#426ab3&quot;, &quot;#d09b2c&quot;, &quot;#000000&quot;, &quot;#b82837&quot;, &quot;#b384b5&quot;, &quot;#ff7200&quot;, &quot;#779de3&quot;, &quot;#cbc8ba&quot;, &quot;#7ed7a6&quot;, &quot;#007a6c&quot;],

    &#x2F;**
     * Collection of default colors used for marker fills in a series when not specified by user.
     *
     * @property _defaultFillColors
     * @type Array
     * @protected
     *&#x2F;
    _defaultFillColors:[&quot;#6084d0&quot;, &quot;#eeb647&quot;, &quot;#6c6b5f&quot;, &quot;#d6484f&quot;, &quot;#ce9ed1&quot;, &quot;#ff9f3b&quot;, &quot;#93b7ff&quot;, &quot;#e0ddd0&quot;, &quot;#94ecba&quot;, &quot;#309687&quot;],
    
    &#x2F;**
     * Collection of default colors used for marker borders in a series when not specified by user.
     *
     * @property _defaultBorderColors
     * @type Array
     * @protected
     *&#x2F;
    _defaultBorderColors:[&quot;#205096&quot;, &quot;#b38206&quot;, &quot;#000000&quot;, &quot;#94001e&quot;, &quot;#9d6fa0&quot;, &quot;#e55b00&quot;, &quot;#5e85c9&quot;, &quot;#adab9e&quot;, &quot;#6ac291&quot;, &quot;#006457&quot;],
    
    &#x2F;**
     * Collection of default colors used for area fills, histogram fills and pie fills in a series when not specified by user.
     *
     * @property _defaultSliceColors
     * @type Array
     * @protected
     *&#x2F;
    _defaultSliceColors: [&quot;#66007f&quot;, &quot;#a86f41&quot;, &quot;#295454&quot;, &quot;#996ab2&quot;, &quot;#e8cdb7&quot;, &quot;#90bdbd&quot;,&quot;#000000&quot;,&quot;#c3b8ca&quot;, &quot;#968373&quot;, &quot;#678585&quot;],

    &#x2F;**
     * Colors used if style colors are not specified
     *
     * @method _getDefaultColor
     * @param {Number} index Index indicating the series order.
     * @param {String} type Indicates which type of object needs the color.
     * @return String
     * @protected
     *&#x2F;
    _getDefaultColor: function(index, type)
    {
        var colors = {
                line: this._defaultLineColors,
                fill: this._defaultFillColors,
                border: this._defaultBorderColors,
                slice: this._defaultSliceColors
            },
            col = colors[type],
            l = col.length;
        index = index || 0;
        if(index &gt;= l)
        {
            index = index % l;
        }
        type = type || &quot;fill&quot;;
        return colors[type][index];
    }
}, {
    ATTRS: {
        &#x2F;**
         * Read-only attribute indicating the type of series.
         *
         * @attribute type
         * @type String
         * @default pie
         *&#x2F;
        type: {		
            value: &quot;pie&quot;
        },
        
        &#x2F;**
         * Order of this instance of this &#x60;type&#x60;.
         *
         * @attribute order
         * @type Number
         *&#x2F;
        order: {},

        &#x2F;**
         * Reference to the &#x60;Graph&#x60; in which the series is drawn into.
         *
         * @attribute graph
         * @type Graph
         *&#x2F;
        graph: {},
        
        &#x2F;**
         * Reference to the &#x60;Axis&#x60; instance used for assigning 
         * category values to the graph.
         *
         * @attribute categoryAxis
         * @type Axis
         *&#x2F;
        categoryAxis: {
            value: null,

            validator: function(value)
            {
                return value !== this.get(&quot;categoryAxis&quot;);
            }
        },
        
        &#x2F;**
         * Reference to the &#x60;Axis&#x60; instance used for assigning 
         * series values to the graph.
         *
         * @attribute categoryAxis
         * @type Axis
         *&#x2F;
        valueAxis: {
            value: null,

            validator: function(value)
            {
                return value !== this.get(&quot;valueAxis&quot;);
            }
        },

        &#x2F;**
         * Indicates which array to from the hash of value arrays in 
         * the category &#x60;Axis&#x60; instance.
         *
         * @attribute categoryKey
         * @type String
         *&#x2F;
        categoryKey: {
            value: null,

            validator: function(value)
            {
                return value !== this.get(&quot;categoryKey&quot;);
            }
        },
        &#x2F;**
         * Indicates which array to from the hash of value arrays in 
         * the value &#x60;Axis&#x60; instance.
         *
         * @attribute valueKey
         * @type String
         *&#x2F;
        valueKey: {
            value: null,

            validator: function(value)
            {
                return value !== this.get(&quot;valueKey&quot;);
            }
        },

        &#x2F;**
         * Name used for for displaying category data
         *
         * @attribute categoryDisplayName
         * @type String
         *&#x2F;
        categoryDisplayName: {
            setter: function(val)
            {
                this._categoryDisplayName = val;
                return val;
            },

            getter: function()
            {
                return this._categoryDisplayName || this.get(&quot;categoryKey&quot;);
            }
        },

        &#x2F;**
         * Name used for for displaying value data
         *
         * @attribute valueDisplayName
         * @type String
         *&#x2F;
        valueDisplayName: {
            setter: function(val)
            {
                this._valueDisplayName = val;
                return val;
            },

            getter: function()
            {
                return this._valueDisplayName || this.get(&quot;valueKey&quot;);
            }
        },
        
        &#x2F;**
         * @attribute slices
         * @type Array
         * @private
         *&#x2F;
        slices: null
        
        &#x2F;**
         * Style properties used for drawing markers. This attribute is inherited from &#x60;MarkerSeries&#x60;. Below are the default values:
         *  &lt;dl&gt;
         *      &lt;dt&gt;fill&lt;&#x2F;dt&gt;&lt;dd&gt;A hash containing the following values:
         *          &lt;dl&gt;
         *              &lt;dt&gt;colors&lt;&#x2F;dt&gt;&lt;dd&gt;An array of colors to be used for the marker fills. The color for each marker is retrieved from the 
         *              array below:&lt;br&#x2F;&gt;
         *              &#x60;[&quot;#66007f&quot;, &quot;#a86f41&quot;, &quot;#295454&quot;, &quot;#996ab2&quot;, &quot;#e8cdb7&quot;, &quot;#90bdbd&quot;,&quot;#000000&quot;,&quot;#c3b8ca&quot;, &quot;#968373&quot;, &quot;#678585&quot;]&#x60;
         *              &lt;&#x2F;dd&gt;
         *              &lt;dt&gt;alphas&lt;&#x2F;dt&gt;&lt;dd&gt;An array of alpha references (Number from 0 to 1) indicating the opacity of each marker fill. The default value is [1].&lt;&#x2F;dd&gt;
         *          &lt;&#x2F;dl&gt;
         *      &lt;&#x2F;dd&gt;
         *      &lt;dt&gt;border&lt;&#x2F;dt&gt;&lt;dd&gt;A hash containing the following values:
         *          &lt;dl&gt;
         *              &lt;dt&gt;color&lt;&#x2F;dt&gt;&lt;dd&gt;An array of colors to be used for the marker borders. The color for each marker is retrieved from the
         *              array below:&lt;br&#x2F;&gt;
         *              &#x60;[&quot;#205096&quot;, &quot;#b38206&quot;, &quot;#000000&quot;, &quot;#94001e&quot;, &quot;#9d6fa0&quot;, &quot;#e55b00&quot;, &quot;#5e85c9&quot;, &quot;#adab9e&quot;, &quot;#6ac291&quot;, &quot;#006457&quot;]&#x60;
         *              &lt;dt&gt;alpha&lt;&#x2F;dt&gt;&lt;dd&gt;Number from 0 to 1 indicating the opacity of the marker border. The default value is 1.&lt;&#x2F;dd&gt;
         *              &lt;dt&gt;weight&lt;&#x2F;dt&gt;&lt;dd&gt;Number indicating the width of the border. The default value is 1.&lt;&#x2F;dd&gt;
         *          &lt;&#x2F;dl&gt;
         *      &lt;&#x2F;dd&gt;
         *      &lt;dt&gt;over&lt;&#x2F;dt&gt;&lt;dd&gt;hash containing styles for markers when highlighted by a &#x60;mouseover&#x60; event. The default 
         *      values for each style is null. When an over style is not set, the non-over value will be used. For example,
         *      the default value for &#x60;marker.over.fill.color&#x60; is equivalent to &#x60;marker.fill.color&#x60;.&lt;&#x2F;dd&gt;
         *  &lt;&#x2F;dl&gt;
         *
         * @attribute styles
         * @type Object
         *&#x2F;
    }
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
