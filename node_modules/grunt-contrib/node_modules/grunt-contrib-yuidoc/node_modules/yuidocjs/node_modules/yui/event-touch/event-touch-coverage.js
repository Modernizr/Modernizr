/*
YUI 3.8.0pr1 (build 140)
Copyright 2012 Yahoo! Inc. All rights reserved.
Licensed under the BSD License.
http://yuilibrary.com/license/
*/
if (typeof _yuitest_coverage == "undefined"){
    _yuitest_coverage = {};
    _yuitest_coverline = function(src, line){
        var coverage = _yuitest_coverage[src];
        if (!coverage.lines[line]){
            coverage.calledLines++;
        }
        coverage.lines[line]++;
    };
    _yuitest_coverfunc = function(src, name, line){
        var coverage = _yuitest_coverage[src],
            funcId = name + ":" + line;
        if (!coverage.functions[funcId]){
            coverage.calledFunctions++;
        }
        coverage.functions[funcId]++;
    };
}
_yuitest_coverage["build/event-touch/event-touch.js"] = {
    lines: {},
    functions: {},
    coveredLines: 0,
    calledLines: 0,
    coveredFunctions: 0,
    calledFunctions: 0,
    path: "build/event-touch/event-touch.js",
    code: []
};
_yuitest_coverage["build/event-touch/event-touch.js"].code=["YUI.add('event-touch', function (Y, NAME) {","","/**","Adds touch event facade normalization properties (touches, changedTouches, targetTouches etc.) to the DOM event facade. Adds","touch events to the DOM events whitelist. ","","@example","    YUI().use('event-touch', function (Y) {","        Y.one('#myDiv').on('touchstart', function(e) {","            ...","        });","    });","@module event","@submodule event-touch"," */","var SCALE = \"scale\",","    ROTATION = \"rotation\",","    IDENTIFIER = \"identifier\",","    win = Y.config.win,","    GESTURE_MAP = {};","","/**"," * Adds touch event facade normalization properties to the DOM event facade"," *"," * @method _touch"," * @for DOMEventFacade"," * @private"," * @param ev {Event} the DOM event"," * @param currentTarget {HTMLElement} the element the listener was attached to"," * @param wrapper {Event.Custom} the custom event wrapper for this DOM event"," */","Y.DOMEventFacade.prototype._touch = function(e, currentTarget, wrapper) {","","    var i,l, etCached, et,touchCache;","","","    if (e.touches) {","","        /**","         * Array of individual touch events for touch points that are still in","         * contact with the touch surface.","         *","         * @property touches","         * @type {DOMEventFacade[]}","         */","        this.touches = [];","        touchCache = {};","","        for (i = 0, l = e.touches.length; i < l; ++i) {","            et = e.touches[i];","            touchCache[Y.stamp(et)] = this.touches[i] = new Y.DOMEventFacade(et, currentTarget, wrapper);","        }","    }","","    if (e.targetTouches) {","","        /**","         * Array of individual touch events still in contact with the touch","         * surface and whose `touchstart` event occurred inside the same taregt","         * element as the current target element.","         *","         * @property targetTouches","         * @type {DOMEventFacade[]}","         */","        this.targetTouches = [];","","        for (i = 0, l = e.targetTouches.length; i < l; ++i) {","            et = e.targetTouches[i];","            etCached = touchCache && touchCache[Y.stamp(et, true)];","","            this.targetTouches[i] = etCached || new Y.DOMEventFacade(et, currentTarget, wrapper);","            ","        }","    }","","    if (e.changedTouches) {","","        /**","        An array of event-specific touch events.","","        For `touchstart`, the touch points that became active with the current","        event.","","        For `touchmove`, the touch points that have changed since the last","        event.","        ","        For `touchend`, the touch points that have been removed from the touch","        surface.","","        @property changedTouches","        @type {DOMEventFacade[]}","        **/","        this.changedTouches = [];","","        for (i = 0, l = e.changedTouches.length; i < l; ++i) {","            et = e.changedTouches[i];","            etCached = touchCache && touchCache[Y.stamp(et, true)];","","            this.changedTouches[i] = etCached || new Y.DOMEventFacade(et, currentTarget, wrapper);","            ","        }","    }","","    if (SCALE in e) {","        this[SCALE] = e[SCALE];","    }","","    if (ROTATION in e) {","        this[ROTATION] = e[ROTATION];","    }","","    if (IDENTIFIER in e) {","        this[IDENTIFIER] = e[IDENTIFIER];","    }","};","","//Adding MSPointer events to whitelisted DOM Events. MSPointer event payloads","//have the same properties as mouse events.","if (Y.Node.DOM_EVENTS) {","    Y.mix(Y.Node.DOM_EVENTS, {","        touchstart:1,","        touchmove:1,","        touchend:1,","        touchcancel:1,","        gesturestart:1,","        gesturechange:1,","        gestureend:1,","        MSPointerDown:1, ","        MSPointerUp:1,","        MSPointerMove:1","    });","}","","//Add properties to Y.EVENT.GESTURE_MAP based on feature detection.","if ((win && (\"ontouchstart\" in win)) && !(Y.UA.chrome && Y.UA.chrome < 6)) {","    GESTURE_MAP.start = \"touchstart\";","    GESTURE_MAP.end = \"touchend\";","    GESTURE_MAP.move = \"touchmove\";","}","","","","else if (win && (\"msPointerEnabled\" in win.navigator)) {","    GESTURE_MAP.start = \"MSPointerDown\";","    GESTURE_MAP.end = \"MSPointerUp\";","    GESTURE_MAP.move = \"MSPointerMove\";","}","","else {","    GESTURE_MAP.start = \"mousedown\";","    GESTURE_MAP.end = \"mouseup\";","    GESTURE_MAP.move = \"mousemove\";","}","","/**"," * A object literal with keys \"start\", \"end\", and \"move\". The value for each key is a"," * string representing the event for that environment. For touch environments, the respective"," * values are \"touchstart\", \"touchend\" and \"touchmove\". Mouse and MSPointer environments are also"," * supported via feature detection."," *"," * @property _GESTURE_MAP"," * @type Object"," * @static"," */","Y.Event._GESTURE_MAP = GESTURE_MAP;","","","}, '3.8.0pr1', {\"requires\": [\"node-base\"]});"];
_yuitest_coverage["build/event-touch/event-touch.js"].lines = {"1":0,"16":0,"32":0,"34":0,"37":0,"46":0,"47":0,"49":0,"50":0,"51":0,"55":0,"65":0,"67":0,"68":0,"69":0,"71":0,"76":0,"93":0,"95":0,"96":0,"97":0,"99":0,"104":0,"105":0,"108":0,"109":0,"112":0,"113":0,"119":0,"120":0,"135":0,"136":0,"137":0,"138":0,"143":0,"144":0,"145":0,"146":0,"150":0,"151":0,"152":0,"165":0};
_yuitest_coverage["build/event-touch/event-touch.js"].functions = {"_touch:32":0,"(anonymous 1):1":0};
_yuitest_coverage["build/event-touch/event-touch.js"].coveredLines = 42;
_yuitest_coverage["build/event-touch/event-touch.js"].coveredFunctions = 2;
_yuitest_coverline("build/event-touch/event-touch.js", 1);
YUI.add('event-touch', function (Y, NAME) {

/**
Adds touch event facade normalization properties (touches, changedTouches, targetTouches etc.) to the DOM event facade. Adds
touch events to the DOM events whitelist. 

@example
    YUI().use('event-touch', function (Y) {
        Y.one('#myDiv').on('touchstart', function(e) {
            ...
        });
    });
@module event
@submodule event-touch
 */
_yuitest_coverfunc("build/event-touch/event-touch.js", "(anonymous 1)", 1);
_yuitest_coverline("build/event-touch/event-touch.js", 16);
var SCALE = "scale",
    ROTATION = "rotation",
    IDENTIFIER = "identifier",
    win = Y.config.win,
    GESTURE_MAP = {};

/**
 * Adds touch event facade normalization properties to the DOM event facade
 *
 * @method _touch
 * @for DOMEventFacade
 * @private
 * @param ev {Event} the DOM event
 * @param currentTarget {HTMLElement} the element the listener was attached to
 * @param wrapper {Event.Custom} the custom event wrapper for this DOM event
 */
_yuitest_coverline("build/event-touch/event-touch.js", 32);
Y.DOMEventFacade.prototype._touch = function(e, currentTarget, wrapper) {

    _yuitest_coverfunc("build/event-touch/event-touch.js", "_touch", 32);
_yuitest_coverline("build/event-touch/event-touch.js", 34);
var i,l, etCached, et,touchCache;


    _yuitest_coverline("build/event-touch/event-touch.js", 37);
if (e.touches) {

        /**
         * Array of individual touch events for touch points that are still in
         * contact with the touch surface.
         *
         * @property touches
         * @type {DOMEventFacade[]}
         */
        _yuitest_coverline("build/event-touch/event-touch.js", 46);
this.touches = [];
        _yuitest_coverline("build/event-touch/event-touch.js", 47);
touchCache = {};

        _yuitest_coverline("build/event-touch/event-touch.js", 49);
for (i = 0, l = e.touches.length; i < l; ++i) {
            _yuitest_coverline("build/event-touch/event-touch.js", 50);
et = e.touches[i];
            _yuitest_coverline("build/event-touch/event-touch.js", 51);
touchCache[Y.stamp(et)] = this.touches[i] = new Y.DOMEventFacade(et, currentTarget, wrapper);
        }
    }

    _yuitest_coverline("build/event-touch/event-touch.js", 55);
if (e.targetTouches) {

        /**
         * Array of individual touch events still in contact with the touch
         * surface and whose `touchstart` event occurred inside the same taregt
         * element as the current target element.
         *
         * @property targetTouches
         * @type {DOMEventFacade[]}
         */
        _yuitest_coverline("build/event-touch/event-touch.js", 65);
this.targetTouches = [];

        _yuitest_coverline("build/event-touch/event-touch.js", 67);
for (i = 0, l = e.targetTouches.length; i < l; ++i) {
            _yuitest_coverline("build/event-touch/event-touch.js", 68);
et = e.targetTouches[i];
            _yuitest_coverline("build/event-touch/event-touch.js", 69);
etCached = touchCache && touchCache[Y.stamp(et, true)];

            _yuitest_coverline("build/event-touch/event-touch.js", 71);
this.targetTouches[i] = etCached || new Y.DOMEventFacade(et, currentTarget, wrapper);
            
        }
    }

    _yuitest_coverline("build/event-touch/event-touch.js", 76);
if (e.changedTouches) {

        /**
        An array of event-specific touch events.

        For `touchstart`, the touch points that became active with the current
        event.

        For `touchmove`, the touch points that have changed since the last
        event.
        
        For `touchend`, the touch points that have been removed from the touch
        surface.

        @property changedTouches
        @type {DOMEventFacade[]}
        **/
        _yuitest_coverline("build/event-touch/event-touch.js", 93);
this.changedTouches = [];

        _yuitest_coverline("build/event-touch/event-touch.js", 95);
for (i = 0, l = e.changedTouches.length; i < l; ++i) {
            _yuitest_coverline("build/event-touch/event-touch.js", 96);
et = e.changedTouches[i];
            _yuitest_coverline("build/event-touch/event-touch.js", 97);
etCached = touchCache && touchCache[Y.stamp(et, true)];

            _yuitest_coverline("build/event-touch/event-touch.js", 99);
this.changedTouches[i] = etCached || new Y.DOMEventFacade(et, currentTarget, wrapper);
            
        }
    }

    _yuitest_coverline("build/event-touch/event-touch.js", 104);
if (SCALE in e) {
        _yuitest_coverline("build/event-touch/event-touch.js", 105);
this[SCALE] = e[SCALE];
    }

    _yuitest_coverline("build/event-touch/event-touch.js", 108);
if (ROTATION in e) {
        _yuitest_coverline("build/event-touch/event-touch.js", 109);
this[ROTATION] = e[ROTATION];
    }

    _yuitest_coverline("build/event-touch/event-touch.js", 112);
if (IDENTIFIER in e) {
        _yuitest_coverline("build/event-touch/event-touch.js", 113);
this[IDENTIFIER] = e[IDENTIFIER];
    }
};

//Adding MSPointer events to whitelisted DOM Events. MSPointer event payloads
//have the same properties as mouse events.
_yuitest_coverline("build/event-touch/event-touch.js", 119);
if (Y.Node.DOM_EVENTS) {
    _yuitest_coverline("build/event-touch/event-touch.js", 120);
Y.mix(Y.Node.DOM_EVENTS, {
        touchstart:1,
        touchmove:1,
        touchend:1,
        touchcancel:1,
        gesturestart:1,
        gesturechange:1,
        gestureend:1,
        MSPointerDown:1, 
        MSPointerUp:1,
        MSPointerMove:1
    });
}

//Add properties to Y.EVENT.GESTURE_MAP based on feature detection.
_yuitest_coverline("build/event-touch/event-touch.js", 135);
if ((win && ("ontouchstart" in win)) && !(Y.UA.chrome && Y.UA.chrome < 6)) {
    _yuitest_coverline("build/event-touch/event-touch.js", 136);
GESTURE_MAP.start = "touchstart";
    _yuitest_coverline("build/event-touch/event-touch.js", 137);
GESTURE_MAP.end = "touchend";
    _yuitest_coverline("build/event-touch/event-touch.js", 138);
GESTURE_MAP.move = "touchmove";
}



else {_yuitest_coverline("build/event-touch/event-touch.js", 143);
if (win && ("msPointerEnabled" in win.navigator)) {
    _yuitest_coverline("build/event-touch/event-touch.js", 144);
GESTURE_MAP.start = "MSPointerDown";
    _yuitest_coverline("build/event-touch/event-touch.js", 145);
GESTURE_MAP.end = "MSPointerUp";
    _yuitest_coverline("build/event-touch/event-touch.js", 146);
GESTURE_MAP.move = "MSPointerMove";
}

else {
    _yuitest_coverline("build/event-touch/event-touch.js", 150);
GESTURE_MAP.start = "mousedown";
    _yuitest_coverline("build/event-touch/event-touch.js", 151);
GESTURE_MAP.end = "mouseup";
    _yuitest_coverline("build/event-touch/event-touch.js", 152);
GESTURE_MAP.move = "mousemove";
}}

/**
 * A object literal with keys "start", "end", and "move". The value for each key is a
 * string representing the event for that environment. For touch environments, the respective
 * values are "touchstart", "touchend" and "touchmove". Mouse and MSPointer environments are also
 * supported via feature detection.
 *
 * @property _GESTURE_MAP
 * @type Object
 * @static
 */
_yuitest_coverline("build/event-touch/event-touch.js", 165);
Y.Event._GESTURE_MAP = GESTURE_MAP;


}, '3.8.0pr1', {"requires": ["node-base"]});
