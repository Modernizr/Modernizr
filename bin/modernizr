#! /usr/bin/env node
const fs = require('fs');
const cwd = process.cwd();
const path = require('path');
const mkdirp = require('mkdirp');
const Modernizr = require(path.resolve(`${__dirname}/../lib/cli.js`));
const yargs = require('yargs')
  .options('h', {
    alias: 'help',
    describe: 'Print Help'
  })
  .options('V', {
    alias: ['v', 'version'],
    describe: 'Print the version and exit'
  })
  .options('f', {
    alias: 'features',
    describe: 'comma separated list of feature detects'
  })
  .options('o', {
    alias: 'options',
    describe: 'comma separated list of extensibility options'
  })
  .options('c', {
    alias: 'config',
    describe: 'Path to a JSON file containing Modernizr configuration. See lib/config-all.json for an example'
  })
  .options('d', {
    alias: 'dest',
    describe: 'Path to write the Modernizr build file to. Defaults to ./modernizr.js'
  })
  .options('m', {
    alias: 'metadata',
    describe: 'Path to where the Modernizr feature-detect metadata should be saved. Defaults to ./metadata.json'
  })
  .options('u', {
    alias: 'uglify',
    describe: 'uglify/minify the output'
  })
  .options('q', {
    alias: 'quiet',
    describe: 'Silence all output'
  });
const argv = yargs.argv;
let dest = `${cwd}/modernizr.js`;
let configPath;
let config;

function log(...args) {
  if (!argv.q) {
    console.log.apply(console, args);
  }
}
function stringify(obj, minified) {
  const replacer = (key, value) => value;
  const args = minified ? [replacer,2] : [];
  args.unshift(obj);
  return JSON.stringify.apply(JSON, args);
}

if (argv.h) {
  yargs.showHelp();
  process.exit();
}

if (argv.V) {
  const pkg = require('../package.json');
  console.log(`Modernizr v${pkg.version}`);
  process.exit();
}

if (argv.d) {
  dest = path.normalize(argv.d);
  const exists = fs.existsSync(dest);
  const isDir = exists && fs.statSync(dest).isDirectory();
  const fileRequested = dest.endsWith('.js');

  if ((exists && isDir) || (!exists && !fileRequested)) {
    dest = path.join(dest, 'modernizr.js');
  }

  mkdirp.sync(path.dirname(dest));
}

if (argv.m) {
  // path.normalize is used instead of resolve in order to support ~
  // we get an absolute path on the fallback from cwd, and any user supplied
  // argument will be relative to their current directory.
  const metaDest = path.normalize(argv.m === true ? `${cwd}/metadata.json` : argv.m);
  Modernizr.metadata(metadata => {
    mkdirp.sync(path.dirname(metaDest));
    fs.writeFileSync(metaDest, stringify(metadata, !argv.u));
    log(`metadata saved to ${metaDest}`);
  });
  if (!argv.d) {
    // return early unless we explicitly request Modernizr to be built
    return;
  }
}

if (argv.o || argv.f) {
  const metadata = Modernizr.metadata();
  const options = Modernizr.options();

  const find = (config, source, isFeature) => {
    if (!config) {
      return;
    }

    return config
      .replace(/-/g, ',')
      .split(',')
      .map(prop => {
        const obj = source.find(({property}) => {
          if (Array.isArray(property)) {
            return property.includes(prop);
          } else {
            return property === prop;
          }
        });

        // setClasses is technically a flag, not an option. But it is passed
        // in as an option. Since it doesn't exist as an option we have to
        // special case around it :[
        if (prop === 'setClasses') {
          return 'setClasses';
        } else if (typeof obj === 'undefined') {
          throw new Error(`${prop} is not a valid ${isFeature ? 'feature detect' : 'option'}`);
        } else {
          return obj.amdPath || obj.property;
        }
      });
  };

  config = {
    'feature-detects': find(argv.f, metadata, true),
    'options': find(argv.o, options)
  };
}

if (argv.c) {
  try {
    configPath = fs.realpathSync(argv.c);
  } catch (e) {
    console.error(`${argv.c} does not exist.`);
    process.exit(1);
  }
  if (!configPath) {
    configPath = path.resolve(__dirname, '../lib/config-all.json');
  }
}

try {
  if (!config && !configPath) {
    console.error('config file, inline features, or options required.');
    yargs.showHelp();
    process.exit(1);
  } else {
    config = config || {};
    if (configPath) {
      config = Object.assign(config, require(configPath));
    }
    if (config && config.dest) {
      dest = path.join(cwd, config.dest, 'modernizr.js');
    }
  }
} catch (e) {
  console.error(`${configPath} is not valid JSON.`);
  console.error(e);
  process.exit(1);
}

if (argv.u) {
  config.minify = true;
}

if (argv.scriptGlobalName) {
  config.scriptGlobalName = argv.scriptGlobalName;
}


config.options = config.options || []
config['feature-detects'] = config['feature-detects'] || []

Modernizr.build(config, output => {
  fs.writeFileSync(dest, output);
  log(`Modernizr build saved to ${dest}`);
});
